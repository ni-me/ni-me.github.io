<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>【转载】汇编语言入门教程 | CodeTrainer</title><meta name="description" content="【转载】汇编语言入门教程"><meta name="author" content="大巴斯基"><meta name="copyright" content="大巴斯基"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【转载】汇编语言入门教程"><meta name="twitter:description" content="【转载】汇编语言入门教程"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="【转载】汇编语言入门教程"><meta property="og:url" content="http://nieblog.me/2018/04/16/汇编语言入门教程/"><meta property="og:site_name" content="CodeTrainer"><meta property="og:description" content="【转载】汇编语言入门教程"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://nieblog.me/2018/04/16/汇编语言入门教程/"><link rel="prev" title="C标准库函数qsort用法" href="http://nieblog.me/2018/04/21/C标准库函数qsort用法/"><link rel="next" title="C/C++中声明与定义的区别" href="http://nieblog.me/2018/04/14/C-C-中声明与定义的区别/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">CodeTrainer</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一-汇编语言是什么"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 一、汇编语言是什么？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二-来历"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 二、来历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三-寄存器"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 三、寄存器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四-寄存器的种类"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 四、寄存器的种类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五-内存模型heap"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 五、内存模型：Heap</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六-内存模型stack"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 六、内存模型：Stack</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七-cpu指令"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 七、CPU指令</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#71一个实例"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 7.1一个实例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#72-push指令"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 7.2 push指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#73-call指令"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text"> 7.3 call指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#74-mov指令"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text"> 7.4 mov指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#75-add指令"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text"> 7.5 add指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#76-pop指令"><span class="toc_mobile_items-number">7.6.</span> <span class="toc_mobile_items-text"> 7.6 pop指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#77-ret指令"><span class="toc_mobile_items-number">7.7.</span> <span class="toc_mobile_items-text"> 7.7 ret指令</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#八-参考链接"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 八、参考链接</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-汇编语言是什么"><span class="toc-number">1.</span> <span class="toc-text"> 一、汇编语言是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-来历"><span class="toc-number">2.</span> <span class="toc-text"> 二、来历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-寄存器"><span class="toc-number">3.</span> <span class="toc-text"> 三、寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-寄存器的种类"><span class="toc-number">4.</span> <span class="toc-text"> 四、寄存器的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-内存模型heap"><span class="toc-number">5.</span> <span class="toc-text"> 五、内存模型：Heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-内存模型stack"><span class="toc-number">6.</span> <span class="toc-text"> 六、内存模型：Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-cpu指令"><span class="toc-number">7.</span> <span class="toc-text"> 七、CPU指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71一个实例"><span class="toc-number">7.1.</span> <span class="toc-text"> 7.1一个实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-push指令"><span class="toc-number">7.2.</span> <span class="toc-text"> 7.2 push指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-call指令"><span class="toc-number">7.3.</span> <span class="toc-text"> 7.3 call指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-mov指令"><span class="toc-number">7.4.</span> <span class="toc-text"> 7.4 mov指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-add指令"><span class="toc-number">7.5.</span> <span class="toc-text"> 7.5 add指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-pop指令"><span class="toc-number">7.6.</span> <span class="toc-text"> 7.6 pop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-ret指令"><span class="toc-number">7.7.</span> <span class="toc-text"> 7.7 ret指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-参考链接"><span class="toc-number">8.</span> <span class="toc-text"> 八、参考链接</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">【转载】汇编语言入门教程</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2018-04-16<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2019-01-14</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p><em>作者：阮一峰</em></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html" target="_blank" rel="noopener">原文链接</a></p>
<p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p>
<p>但是，计算机不理解高级语言，必须通过编译器转换成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/1.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/1.png" alt title></a></p>
<p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制CPU的运行。如果你想了解CPU到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>
<p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释CPU如何执行代码。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/2.jpg" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/2.jpg" alt title></a></p>
<h2 id="一-汇编语言是什么"><a class="markdownIt-Anchor" href="#一-汇编语言是什么"></a> 一、汇编语言是什么？</h2>
<p>我们知道，CPU只负责计算，本身不具备智能。你输入一条指令(instruction)，它就运行一次，然后停下来，等待下一条指令。</p>
<p>这些指令都是二进制的，称为操作码(opcode)，比如加法指令就是<code>00000011</code>。编译器的作用，就是将用高级语言写好的程序，翻译成一条条操作码。</p>
<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/3.jpg" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/3.jpg" alt title></a></p>
<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一 一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是<code>ADD</code>。只要还原成二进制，汇编语言就可以被CPU直接执行，所以它是最底层的低级语言。</p>
<h2 id="二-来历"><a class="markdownIt-Anchor" href="#二-来历"></a> 二、来历</h2>
<p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>
<p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成<code>ADD</code>。内存地址也不再直接引用，而是用标签表示。</p>
<p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做assembly code。标准化以后，称为 assembly language，缩写为asm，中文译为汇编语言。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/4.jpg" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/4.jpg" alt title></a></p>
<p><strong>每一种CPU的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的CPU使用的那一种</strong>。</p>
<h2 id="三-寄存器"><a class="markdownIt-Anchor" href="#三-寄存器"></a> 三、寄存器</h2>
<p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>
<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU要用的时候就去内存读写数据。但是，<strong>CPU的运算速度远高于内存的读写速度</strong>，为了避免被拖慢，CPU都自带一级缓存和二级缓存。基本上，<strong>CPU缓存可以看作是读写速度较快的内存</strong>。</p>
<p>但是，CPU缓存还是不够快，另外<strong>数据在缓存里面的地址是不固定的</strong>，CPU每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU还自带<strong>寄存器(register)</strong>，用来储存最常用的数据。也就是说，那些最频繁读写的数据(比如循环变量)，都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。<br>
<a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/5.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/5.png" alt title></a></p>
<p><strong>寄存器不依靠地址区分数据，而是依靠名称</strong>。每一个寄存器都有自己的名称，我们告诉CPU去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<h2 id="四-寄存器的种类"><a class="markdownIt-Anchor" href="#四-寄存器的种类"></a> 四、寄存器的种类</h2>
<p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">asciidoc</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>EAX</div><div class="line"><span class="bullet">* </span>EBX</div><div class="line"><span class="bullet">* </span>ECX</div><div class="line"><span class="bullet">* </span>EDX</div><div class="line"><span class="bullet">* </span>EDI</div><div class="line"><span class="bullet">* </span>ESI</div><div class="line"><span class="bullet">* </span>EBP</div><div class="line"><span class="bullet">* </span>ESP</div></pre></td></tr></table></figure></div>
<p>上面这8个寄存器之中，前面7个都是通用的。ESP寄存器有特定用途，保存当前Stack的地址。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/6.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/6.png" alt title></a></p>
<p>我们常常看到32位CPU、64位CPU这样的名称，其实指的就是寄存器的大小。32位CPU的寄存器大小就是4个字节。</p>
<h2 id="五-内存模型heap"><a class="markdownIt-Anchor" href="#五-内存模型heap"></a> 五、内存模型：Heap</h2>
<p>寄存器只能存放很少量的数据，大多数时候，CPU要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎样储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内有起始地址和结束地址，比如<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/7.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/7.png" alt title></a></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是<strong>从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）</strong>。举例来说，用户要求得到10字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果在要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/8.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/8.png" alt title></a></p>
<p>这种因为<em><strong>用户请求而划分出来的内存区域***，叫做Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap的一个重要特点就是</strong>不会自动消失</em>*，必须手动释放，或者由垃圾回收机制来回收。</p>
<a id="more"></a>
<h2 id="六-内存模型stack"><a class="markdownIt-Anchor" href="#六-内存模型stack"></a> 六、内存模型：Stack</h2>
<p>除了Heap以外，其他的内存占用叫做Stack（栈）。简单说，Stack是由于<strong>函数运行而临时占用的内存区域</strong>。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/9.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/9.png" alt title></a></p>
<p>请看下面的例子。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">2</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧(frame)，所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code><strong>函数执行结束后，该帧就会被回收，释放所有的内部变量，不在占用空间</strong>。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/10.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/10.png" alt title></a></p>
<p>如果函数内部调用了其他函数，会发生什么情况？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">2</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">3</span>;</div><div class="line">	<span class="keyword">return</span> add_a_and_b(a, b); </div><div class="line">&#125;</div></pre></td></tr></table></figure></div>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈多少层，就有多少帧。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/11.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/11.png" alt title></a></p>
<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack ，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做“入栈”，英文是 push ；栈的回收叫做“出栈”，英文是 pop。</p>
<p>Stack 的特点就是，<strong>最晚入栈的帧最早出栈</strong>（因为最内层的函数调用，最先结束运行），这就叫做“后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/12.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/12.png" alt title></a></p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/13.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/13.png" alt title></a></p>
<p>Stack 是由内存区域的结束地址开始，<strong>从高位（地址）向低位（地址）分配</strong>。比如内存的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定是64字节，那么地址就会移动到<code>0x7FB0</code></p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/14.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/14.png" alt title></a></p>
<h2 id="七-cpu指令"><a class="markdownIt-Anchor" href="#七-cpu指令"></a> 七、CPU指令</h2>
<h3 id="71一个实例"><a class="markdownIt-Anchor" href="#71一个实例"></a> 7.1一个实例</h3>
<p>了解寄存器和内存模型以后，就可以来看看汇编语言到底是什么。下面是一个简单的程序<code>example</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_a_and_b</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">return</span> add_a_and_b(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></div>
<p>gcc将这个程序转成汇编语言。</p>
<p><code>$ gcc -S example.c</code></p>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个CPU指令构成。CPU依次执行这些指令，完成这一步操作。</p>
<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">llvm</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">_add_a_and_b:</div><div class="line">	push   <span class="symbol">%ebx</span></div><div class="line">	mov    <span class="symbol">%eax</span>, [<span class="symbol">%esp</span>+<span class="number">8</span>]</div><div class="line">	mov    <span class="symbol">%ebx</span>, [<span class="symbol">%esp</span>+<span class="number">12</span>]</div><div class="line">	<span class="keyword">add</span>    <span class="symbol">%eax</span>, <span class="symbol">%ebx</span></div><div class="line">	pop    <span class="symbol">%ebx</span></div><div class="line">	<span class="keyword">ret</span></div><div class="line"></div><div class="line">_main</div><div class="line">	push    <span class="number">3</span></div><div class="line">	push    <span class="number">2</span></div><div class="line">	<span class="keyword">call</span>    _add_a_and_b</div><div class="line">	<span class="keyword">add</span>     <span class="symbol">%esp</span>, <span class="number">8</span></div><div class="line">	<span class="keyword">ret</span></div></pre></td></tr></table></figure></div>
<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转化的CPU运行流程。</p>
<p>每一行就是CPU所执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<p><code>push %ebx</code></p>
<p>这一行里面，<code>push</code>是CPU指令，<code>%ebx</code>是该指令要用到的运算子。一个CPU指令可以有零个到多个运算子。</p>
<h3 id="72-push指令"><a class="markdownIt-Anchor" href="#72-push指令"></a> 7.2 push指令</h3>
<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入ESP寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在ESP寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<p><code>push 3</code><br>
<code>push</code>指令用于将运算子放入 Stack ，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出ESP寄存器里面的地址，将其减去4个字节，然后将新地址写入ESP寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后，3就会写入这个地址开始的四个字节。</p>
<p><code>push 2</code></p>
<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP寄存器会再减去4个字节（累计减去8）。</p>
<p><a href="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/15.png" data-fancybox="group" data-caption class="fancybox"><img src="https://blog-1252579361.cos.ap-beijing.myqcloud.com/18_4_16/15.png" alt title></a></p>
<h3 id="73-call指令"><a class="markdownIt-Anchor" href="#73-call指令"></a> 7.3 call指令</h3>
<p>第三行的<code>call</code>指令用来调用函数。</p>
<p><code>call _add_a_and_b</code></p>
<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>
<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>
<p><code>push %ebx</code></p>
<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>
<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>
<h3 id="74-mov指令"><a class="markdownIt-Anchor" href="#74-mov指令"></a> 7.4 mov指令</h3>
<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<p><code>mov		%eax, [%esp+8]</code></p>
<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址再 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>
<p>下一行代码也是干同样的事情。</p>
<p><code>mov		%ebx, [%esp+12]</code></p>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>
<h3 id="75-add指令"><a class="markdownIt-Anchor" href="#75-add指令"></a> 7.5 add指令</h3>
<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<p><code>add		%eax, %ebx</code></p>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>
<h3 id="76-pop指令"><a class="markdownIt-Anchor" href="#76-pop指令"></a> 7.6 pop指令</h3>
<p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>
<p><code>pop		%ebx</code></p>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>
<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>
<h3 id="77-ret指令"><a class="markdownIt-Anchor" href="#77-ret指令"></a> 7.7 ret指令</h3>
<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是说，当前函数的帧将被回收。</p>
<p><code>ret</code></p>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<p><code>add		%esp, 8</code></p>
<p>上面函数表示，将 ESP 寄存器里面的地址，手动加上8个字节， 再写回 ESP 寄存器。这是因为 ESP 寄存器写入的是 Stack 的开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<p><code>ret</code></p>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>
<hr>
<h2 id="八-参考链接"><a class="markdownIt-Anchor" href="#八-参考链接"></a> 八、参考链接</h2>
<p><a href="http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/" target="_blank" rel="noopener">Introduction to reverse engineering and Assembly</a>,by Youness Alaoui</p>
<p><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html" target="_blank" rel="noopener">x86 Assembly Guide</a>,by University of Virginia Computer Science</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">大巴斯基</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://nieblog.me/2018/04/16/汇编语言入门教程/">http://nieblog.me/2018/04/16/汇编语言入门教程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://nieblog.me">CodeTrainer</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/04/21/C标准库函数qsort用法/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>C标准库函数qsort用法</span></div></a></div><div class="next-post pull_right"><a href="/2018/04/14/C-C-中声明与定义的区别/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>C/C++中声明与定义的区别</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By 大巴斯基</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>